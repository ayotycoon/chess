{"version":3,"sources":["chess/engine/ChessPiece.ts","chess/engine/ChessQueen.ts","chess/engine/ChessPawn.ts","chess/engine/ChessBishop.ts","chess/engine/ChessRook.ts","chess/engine/ChessKing.ts","chess/engine/ChessKnight.ts","chess/engine/ChessBoard.ts","chess/index.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["ChessPiece","board","positionYIndex","positionXIndex","isPieceWhite","name","icon","availableXMovements","availableYMovements","successfulMovements","id","Math","random","king","oppKing","anticipateOppMoves","_","i","length","j","cellPiece","availableMoves","forEach","m","anticipateMyMoves","cell","this","undefined","yIndex","xIndex","cb","canmove","movements","temp","previousPositionYIndex","previousPositionXIndex","alert","ChessQueen","indexes","analyzeAndBreak","incY","incX","possiblePiece","push","max","map","index","positionY","positionX","ChessPawn","_parent","prototype","move","apply","queen","incY1","incY2","ChessBishop","ChessRook","ChessKing","curr","ChessKnight","ChessBoard","blackKing","whiteKing","JSON","stringify","r","boardWidth","min","window","innerHeight","innerWidth","pieceWidth","ChessGame","useState","setBoard","setAvailableMoves","selectedPiece","setSelectedPiece","chessBoard","useRef","current","isWhiteTurnToPlay","setIsWhiteTurnToPlay","reloadBoard","useEffect","className","style","width","height","row","y","display","piece","x","shouldHighlight","onClick","a","onPieceClick","backgroundColor","justifyContent","alignItems","color","padding","App","path","component","to","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.3cc2eae7.chunk.js","sourcesContent":["import { ChessKing } from \"./ChessKing\";\n\nexport abstract class ChessPiece {\n    name = 'piece'\n    icon = 'chess'\n    availableXMovements = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'];\n    availableYMovements = ['1', '2', '3', '4', '5', '6', '7', '8'];\n\n    positionXIndex = 0;\n    positionYIndex = 0;\n    isPieceWhite = true;\n    successfulMovements = 0;\n\n    board: ChessPiece[][] |  null[][] = [[]]\n    id = (1 + Math.random()) * 100000000;\n\n    king:ChessKing | null = null;\n    oppKing:ChessKing | null = null;\n\n    constructor(\n        board: ChessPiece[][] |  null[][],\n        positionYIndex: number,\n        positionXIndex: number,\n        isPieceWhite: boolean\n    ) {\n        this.board = board;\n        this.isPieceWhite = isPieceWhite === undefined ? positionYIndex > 2 : isPieceWhite;\n        this.positionYIndex = positionYIndex;\n        this.positionXIndex = positionXIndex;\n\n    }\n\n    anticipateOppMoves = () => {\n        const _:{[id:string]:boolean} = {}\n        for (let i = 0; i < this.board.length; i++) {\n            for (let j = 0; j < this.board[i].length; j++) {\n                const cellPiece = this.board[i][j];\n                if (cellPiece && cellPiece.isPieceWhite !== this.isPieceWhite) {\n                    cellPiece.availableMoves()\n                        .forEach(m => {\n                            _[m.positionYIndex + \",\" + m.positionXIndex] = true\n                        })\n                }\n\n            }\n        }\n        return _;\n    }\n    anticipateMyMoves = () => {\n        const _ = {}\n        for (let i = 0; i < this.board.length; i++) {\n            for (let j = 0; j < this.board[i].length; j++) {\n                const cell = this.board[i][j];\n                if (cell && cell.isPieceWhite === this.isPieceWhite) {\n                    cell.availableMoves()\n                        .forEach(m => {\n                            _[m.positionYIndex + \",\" + m.positionXIndex] = true\n                        })\n                }\n\n            }\n        }\n        return _;\n    }\n\n    move(yIndex:number, xIndex:number, cb?: () => void) {\n        const availableMoves = this.availableMoves();\n        let canmove = false;\n        availableMoves.forEach(movements => {\n\n            if (movements.positionYIndex === yIndex && movements.positionXIndex === xIndex) {\n                canmove = true;\n            }\n        })\n\n        if (!canmove) {\n            return false;\n        }\n        // swap pos in board;\n        const temp = this.board[this.positionYIndex][this.positionXIndex]\n\n\n\n        this.board[this.positionYIndex][this.positionXIndex] = null;\n\n        const previousPositionYIndex = this.positionYIndex;\n        const previousPositionXIndex = this.positionXIndex;\n        this.positionYIndex = yIndex;\n        this.positionXIndex = xIndex;\n\n        // assign new pos\n        this.board[this.positionYIndex][this.positionXIndex] = temp;\n        // test to see if the move puts the king at risk\n        const oppMoves = this.anticipateOppMoves();\n        if (oppMoves[this.king?.positionYIndex + ',' + this.king?.positionXIndex]) {\n            // king is at risk\n            // revert move\n            alert('king at risk')\n\n            this.board[this.positionYIndex][this.positionXIndex] = null;\n\n            this.positionYIndex = previousPositionYIndex;\n            this.positionXIndex = previousPositionXIndex;\n\n            this.board[previousPositionYIndex][previousPositionXIndex] = temp;\n\n\n            return false;\n        }\n        const myMoves = this.anticipateMyMoves();\n        if (myMoves[this.oppKing?.positionYIndex + ',' + this.oppKing?.positionXIndex]) {\n            // king is at risk\n            // revert move\n            alert('check')\n\n\n\n        }\n\n        if (cb) {\n            cb()\n        }\n\n        this.successfulMovements++;\n        return true;\n\n\n    }\n    availableMoves = () => {\n        return [] as {\n            positionYIndex: number;\n            positionY: string;\n            positionXIndex: number;\n            positionX: string;\n        }[]\n    \n}\n\n    toString() {\n        return `name = ${this.name} \\ntype = ${this.isPieceWhite ? 'White' : 'Black'} \\nposition = ${this.availableXMovements[this.positionXIndex]}${this.availableYMovements[this.positionYIndex]}`;\n    }\n    currentPosition() {\n        return `Y = ${this.positionYIndex}, X = ${this.positionXIndex}`\n    }\n\n\n}\n","import { ChessPiece } from \"./ChessPiece\";\n\nexport class ChessQueen extends ChessPiece {\n    name = 'queen'\n    icon = 'fas fa-chess-queen'\n    constructor(\n        board:ChessPiece[][] |  null[][],\n        positionYIndex:number,\n        positionXIndex:number,\n        isPieceWhite:boolean\n        ) {\n        super(board,positionYIndex, positionXIndex,isPieceWhite);\n    }\n\n    availableMoves = () => {\n        let indexes:{\n            positionYIndex:number\n            positionXIndex:number\n\n\n        }[] = [];\n\n        // check up\n\n\n\n\n        const analyzeAndBreak = (incY,incX) => {\n            if(incY < 0 || incY > 7 || incX < 0 || incX >7) return true;\n            const possiblePiece = this.board[incY][incX]\n            if (!possiblePiece) {\n                indexes.push({ positionYIndex: incY, positionXIndex: incX })\n\n            } else if (possiblePiece.isPieceWhite === this.isPieceWhite) {\n                // if its same color\n                return true\n\n            } else {\n                indexes.push({ positionYIndex: incY, positionXIndex: incX })\n\n                return true\n\n            }\n        }\n\n\n\n            for (let i = this.positionYIndex + 1; i < 8; i++) {\n                const incY = i;\n                const incX = this.positionXIndex\n               \n\n                if (analyzeAndBreak( incY,incX)) {\n                    break;\n                }\n            }\n            for (let i = this.positionYIndex - 1; i >= 0; i--) {\n                const incY = i;\n                const incX = this.positionXIndex\n               \n\n                if (analyzeAndBreak( incY,incX)) {\n                    break;\n                }\n            }\n            for (let i = this.positionXIndex + 1; i < 8; i++) {\n                const incX = i;\n                const incY = this.positionYIndex\n               \n\n                if (analyzeAndBreak( incY,incX)) {\n                    break;\n                }\n            }\n            for (let i = this.positionXIndex - 1; i >= 0; i--) {\n                const incX = i;\n                const incY = this.positionYIndex\n               \n\n                if (analyzeAndBreak( incY,incX)) {\n                    break;\n                }\n            }\n\n            // do diagonal \n\n\n            for (let i = 1; i < (8-this.positionYIndex); i++) {\n                const incY = this.positionYIndex + i;\n                const incX = this.positionXIndex + i;\n               \n\n                if (analyzeAndBreak( incY,incX)) {\n                    break;\n                }\n            }\n            for (let i = 1; i < Math.max(this.positionYIndex, this.positionXIndex); i++) {\n                const incY = this.positionYIndex - i;\n                const incX = this.positionXIndex -i\n               \n\n                if (analyzeAndBreak( incY,incX)) {\n                    break;\n                }\n            }\n        \n\n\n            for (let i = 1; i < (8-this.positionYIndex); i++) {\n                const incY = this.positionYIndex + i;\n                const incX = this.positionXIndex - i;\n               \n\n                if (analyzeAndBreak( incY,incX)) {\n                    break;\n                }\n            }\n            for (let i = 1; i <= this.positionYIndex; i++) {\n                const incY = this.positionYIndex - i;\n                const incX = this.positionXIndex + i\n               \n\n                if (analyzeAndBreak( incY,incX)) {\n                    break;\n                }\n            }\n        \n\n\n\n\n\n\n\n        return indexes.map(index => {\n            return {\n\n                positionYIndex: index.positionYIndex,\n                positionY: this.availableYMovements[index.positionYIndex],\n                positionXIndex: index.positionXIndex,\n                positionX: this.availableXMovements[index.positionYIndex]\n            }\n        })\n    }\n\n\n}\n","import { ChessQueen } from \"./ChessQueen\";\nimport { ChessPiece } from \"./ChessPiece\";\n\nexport class ChessPawn extends ChessPiece {\n    name = 'pawn'\n    icon = 'fas fa-chess-pawn'\n    _parent = ChessPiece.prototype\n     constructor(\n        board:ChessPiece[][] |  null[][],\n        positionYIndex:number,\n        positionXIndex:number,\n        isPieceWhite:boolean\n        ) {\n        super(board, positionYIndex, positionXIndex, isPieceWhite);\n    }\n\n    move = (yIndex:number, xIndex:number) => {\n\n        return this._parent.move.apply(this, [yIndex, xIndex, () => {\n            // check if its promotable\n\n            if (this.isPieceWhite && yIndex === 0 || !this.isPieceWhite && yIndex === 7) {\n                // promote\n                const queen = new ChessQueen(this.board, yIndex, this.positionXIndex, this.isPieceWhite);\n                queen.king = this.king;\n                queen.oppKing = this.oppKing;\n                this.board[this.positionYIndex][this.positionXIndex] = queen;\n            }\n\n\n        }])\n    }\n\n    availableMoves = () => {\n        let indexes:{\n            positionYIndex:number\n            positionXIndex:number\n\n\n        }[] = [];\n        const incY1 = !this.isPieceWhite ? 1 : -1;\n        const incY2 = !this.isPieceWhite ? 2 : -2;\n\n\n\n\n        // check if it can move a step in y axes and if its own piece isnt on its moves\n\n\n        if (this.positionYIndex + incY1 < this.availableXMovements.length && this.positionYIndex + incY1 >= 0 && !this.board[this.positionYIndex + incY1][this.positionXIndex]) {\n            indexes.push({ positionYIndex: this.positionYIndex + incY1, positionXIndex: this.positionXIndex })\n\n            if (this.successfulMovements === 0) {\n                // check if its first time, only move if theres nothing in the way\n\n                if (this.positionYIndex + incY2 < this.availableYMovements.length && this.positionYIndex + incY2 >= 0 && !this.board[this.positionYIndex + incY2][this.positionXIndex]) {\n                    indexes.push({ positionYIndex: this.positionYIndex + incY2, positionXIndex: this.positionXIndex })\n\n                }\n            }\n\n\n\n        }\n\n\n\n    \n        if (this.positionYIndex + incY1 < this.availableYMovements.length && this.positionYIndex + incY1 >= 0  && this.board[this.positionYIndex + incY1][this.positionXIndex + 1]?.isPieceWhite === !this.isPieceWhite) {\n            indexes.push({ positionYIndex: this.positionYIndex + incY1, positionXIndex: this.positionXIndex + 1 })\n            // check diagonal if an opp is there\n        }\n \n        if (this.positionYIndex + incY1 < this.availableYMovements.length  && this.board[this.positionYIndex + incY1][this.positionXIndex - 1]?.isPieceWhite === !this.isPieceWhite) {\n            indexes.push({ positionYIndex: this.positionYIndex + incY1, positionXIndex: this.positionXIndex - 1 })\n            // check diagonal if an opp is there\n        }\n\n\n\n\n\n\n\n        return indexes.map(index => {\n            return {\n\n                positionYIndex: index.positionYIndex,\n                positionY: this.availableYMovements[index.positionYIndex],\n                positionXIndex: index.positionXIndex,\n                positionX: this.availableXMovements[index.positionYIndex]\n            }\n        })\n    }\n\n\n}\n","import { ChessPiece } from \"./ChessPiece\";\n\nexport class ChessBishop extends ChessPiece {\n    name = 'bishop'\n    icon = 'fas fa-chess-bishop'\n     constructor(\n        board:ChessPiece[][] |  null[][],\n        positionYIndex:number,\n        positionXIndex:number,\n        isPieceWhite:boolean\n        ) {\n        super(board, positionYIndex, positionXIndex, isPieceWhite);\n    }\n\n    availableMoves = () => {\n        let indexes:{\n            positionYIndex:number\n            positionXIndex:number\n\n\n        }[] = [];\n\n        // check up\n\n\n\n\n        const analyzeAndBreak = (incY, incX) => {\n            if (incY < 0 || incY > 7 || incX < 0 || incX > 7) return true;\n            const possiblePiece = this.board[incY][incX]\n            if (!possiblePiece) {\n                indexes.push({ positionYIndex: incY, positionXIndex: incX })\n\n            } else if (possiblePiece.isPieceWhite === this.isPieceWhite) {\n                // if its same color\n                return true\n\n            } else {\n                indexes.push({ positionYIndex: incY, positionXIndex: incX })\n\n                return true\n\n            }\n        }\n\n\n\n\n        // do diagonal \n\n\n        for (let i = 1; i < (8 - this.positionYIndex); i++) {\n            const incY = this.positionYIndex + i;\n            const incX = this.positionXIndex + i;\n\n\n            if (analyzeAndBreak(incY, incX)) {\n                break;\n            }\n        }\n        for (let i = 1; i < Math.max(this.positionYIndex, this.positionXIndex); i++) {\n            const incY = this.positionYIndex - i;\n            const incX = this.positionXIndex - i\n\n\n            if (analyzeAndBreak(incY, incX)) {\n                break;\n            }\n        }\n\n\n\n        for (let i = 1; i < (8 - this.positionYIndex); i++) {\n            const incY = this.positionYIndex + i;\n            const incX = this.positionXIndex - i;\n\n\n            if (analyzeAndBreak(incY, incX)) {\n                break;\n            }\n        }\n        for (let i = 1; i <= Math.max(this.positionYIndex,this.positionXIndex); i++) {\n            const incY = this.positionYIndex - i;\n            const incX = this.positionXIndex + i\n\n\n            if (analyzeAndBreak(incY, incX)) {\n                break;\n            }\n        }\n\n\n\n\n\n\n        return indexes.map(index => {\n            return {\n\n                positionYIndex: index.positionYIndex,\n                positionY: this.availableYMovements[index.positionYIndex],\n                positionXIndex: index.positionXIndex,\n                positionX: this.availableXMovements[index.positionYIndex]\n            }\n        })\n    }\n\n\n}\n","import { ChessPiece } from \"./ChessPiece\";\n\nexport class ChessRook extends ChessPiece {\n    name = 'rook'\n    icon = 'fas fa-chess-rook'\n    constructor(\n        board:ChessPiece[][] |  null[][],\n        positionYIndex:number,\n        positionXIndex:number,\n        isPieceWhite:boolean\n        ) {\n        super(board,positionYIndex, positionXIndex,isPieceWhite);\n    }\n\n    availableMoves = () => {\n        let indexes:{\n            positionYIndex:number\n            positionXIndex:number\n\n\n        }[] = [];\n\n        // check up\n\n\n\n\n        const analyzeAndBreak = (incY,incX) => {\n            if(incY < 0 || incY > 7 || incX < 0 || incX >7) return true;\n            const possiblePiece = this.board[incY][incX]\n            if (!possiblePiece) {\n                indexes.push({ positionYIndex: incY, positionXIndex: incX })\n\n            } else if (possiblePiece.isPieceWhite === this.isPieceWhite) {\n                // if its same color\n                return true\n\n            } else {\n                indexes.push({ positionYIndex: incY, positionXIndex: incX })\n\n                return true\n\n            }\n        }\n\n\n\n            for (let i = this.positionYIndex + 1; i < 8; i++) {\n                const incY = i;\n                const incX = this.positionXIndex\n               \n\n                if (analyzeAndBreak( incY,incX)) {\n                    break;\n                }\n            }\n            for (let i = this.positionYIndex - 1; i >= 0; i--) {\n                const incY = i;\n                const incX = this.positionXIndex\n               \n\n                if (analyzeAndBreak( incY,incX)) {\n                    break;\n                }\n            }\n            for (let i = this.positionXIndex + 1; i < 8; i++) {\n                const incX = i;\n                const incY = this.positionYIndex\n               \n\n                if (analyzeAndBreak( incY,incX)) {\n                    break;\n                }\n            }\n            for (let i = this.positionXIndex - 1; i >= 0; i--) {\n                const incX = i;\n                const incY = this.positionYIndex\n               \n\n                if (analyzeAndBreak( incY,incX)) {\n                    break;\n                }\n            }\n\n            // do diagonal \n\n\n\n\n\n\n\n\n\n        return indexes.map(index => {\n            return {\n\n                positionYIndex: index.positionYIndex,\n                positionY: this.availableYMovements[index.positionYIndex],\n                positionXIndex: index.positionXIndex,\n                positionX: this.availableXMovements[index.positionYIndex]\n            }\n        })\n    }\n\n\n}\n","import { ChessPiece } from \"./ChessPiece\";\n\nexport class ChessKing extends ChessPiece {\n    name = 'king'\n    icon = 'fas fa-chess-king'\n    constructor(\n        board:ChessPiece[][] |  null[][],\n        positionYIndex:number,\n        positionXIndex:number,\n        isPieceWhite:boolean\n        ) {\n        super(board,positionYIndex, positionXIndex,isPieceWhite);\n    }\n\n    availableMoves = () => {\n        let indexes:{\n            positionYIndex:number\n            positionXIndex:number\n\n\n        }[] = [];\n\n        // check up\n\n\n\n\n        const analyzeAndBreak = (incY,incX) => {\n            if(incY < 0 || incY > 7 || incX < 0 || incX >7) return true;\n            const possiblePiece = this.board[incY][incX]\n            if (!possiblePiece) {\n                indexes.push({ positionYIndex: incY, positionXIndex: incX })\n\n            } else if (possiblePiece.isPieceWhite === this.isPieceWhite) {\n                // if its same color\n                return true\n\n            } else {\n                indexes.push({ positionYIndex: incY, positionXIndex: incX })\n\n                return true\n\n            }\n        }\n\n\n\n       \n        const movements = [\n            [1,0],\n            [0,1],\n            [-1,0],\n            [0,-1],\n\n            [1,1],\n            [-1,-1],\n            [-1,1],\n            [1,-1],\n\n\n\n        ]\n        \n\n\n            for (let i = 0; i < movements.length; i++) {\n                const curr = movements[i]\n                const incY = this.positionYIndex + curr[0];\n                const incX = this.positionXIndex + curr[1];\n               \n\n                analyzeAndBreak( incY,incX)\n            }\n          \n\n\n\n\n\n\n\n        return indexes.map(index => {\n            return {\n\n                positionYIndex: index.positionYIndex,\n                positionY: this.availableYMovements[index.positionYIndex],\n                positionXIndex: index.positionXIndex,\n                positionX: this.availableXMovements[index.positionYIndex]\n            }\n        })\n    }\n\n\n}\n","import { ChessPiece } from \"./ChessPiece\";\n\nexport class ChessKnight extends ChessPiece {\n    name = 'knight'\n    icon = 'fas fa-chess-knight'\n     constructor(\n        board:ChessPiece[][] |  null[][],\n        positionYIndex:number,\n        positionXIndex:number,\n        isPieceWhite:boolean\n        ) {\n        super(board,positionYIndex, positionXIndex,isPieceWhite);\n    }\n\n\n\n    availableMoves = () => {\n        let indexes:{\n            positionYIndex:number\n            positionXIndex:number\n\n\n        }[] = [];\n\n        // check up\n\n\n\n\n        const analyzeAndBreak = (incY,incX) => {\n   \n            if(incY < 0 || incY > 7 || incX < 0 || incX >7) return true;\n           \n          \n           \n            const possiblePiece = this.board[incY][incX]\n            if (!possiblePiece) {\n                indexes.push({ positionYIndex: incY, positionXIndex: incX })\n\n            } else if (possiblePiece.isPieceWhite === this.isPieceWhite) {\n                // if its same color\n             //   return true\n\n            } else {\n                indexes.push({ positionYIndex: incY, positionXIndex: incX })\n\n                return true\n\n            }\n        }\n\n\n\n       \n        const movements = [\n            [2,1],\n            [2,-1],\n            [-2,1],\n            [-2,-1],\n            [1,2],\n            [1,-2],\n            [-1,2],\n            [-1,-2],\n      \n\n\n\n        ]\n        \n\n\n            for (let i = 0; i < movements.length; i++) {\n                const curr = movements[i]\n                const incY = this.positionYIndex + curr[0];\n                const incX = this.positionXIndex + curr[1];\n               \n\n                analyzeAndBreak( incY,incX)\n            }\n          \n\n\n\n\n\n\n\n        return indexes.map(index => {\n            return {\n\n                positionYIndex: index.positionYIndex,\n                positionY: this.availableYMovements[index.positionYIndex],\n                positionXIndex: index.positionXIndex,\n                positionX: this.availableXMovements[index.positionYIndex]\n            }\n        })\n    }\n\n\n\n}\n","import { ChessPawn } from \"./ChessPawn\";\nimport { ChessQueen } from \"./ChessQueen\";\nimport { ChessBishop } from \"./ChessBishop\";\nimport { ChessRook } from \"./ChessRook\";\nimport { ChessKing } from \"./ChessKing\";\nimport { ChessKnight } from \"./ChessKnight\";\n\n\n\nexport class ChessBoard {\n    board:ChessKing[][] | null[][] = [\n        [null, null, null, null, null, null, null, null],\n        [null, null, null, null, null, null, null, null],\n        [null, null, null, null, null, null, null, null],\n        [null, null, null, null, null, null, null, null],\n        [null, null, null, null, null, null, null, null],\n        [null, null, null, null, null, null, null, null],\n        [null, null, null, null, null, null, null, null],\n        [null, null, null, null, null, null, null, null],\n    ]\n\n    constructor() {\n        const blackKing = new ChessKing(this.board, 0, 3,false);\n        this.board[0][3] = blackKing\n\n        this.board[0][0] = new ChessRook(this.board, 0, 0,false);\n        this.board[0][7] = new ChessRook(this.board, 0, 7,false);\n\n        this.board[0][1] = new ChessKnight(this.board, 0, 1,false);\n        this.board[0][6] = new ChessKnight(this.board, 0, 6,false);\n\n        this.board[0][4] = new ChessQueen(this.board, 0, 4,false);\n        this.board[0][2] = new ChessBishop(this.board, 0, 2,false);\n        this.board[0][5] = new ChessBishop(this.board, 0, 5,false);\n\n        this.board[1][0] = new ChessPawn(this.board, 1, 0,false);\n        this.board[1][1] = new ChessPawn(this.board, 1, 1,false);\n        this.board[1][2] = new ChessPawn(this.board, 1, 2,false);\n        this.board[1][3] = new ChessPawn(this.board, 1, 3,false);\n        this.board[1][4] = new ChessPawn(this.board, 1, 4,false);\n        this.board[1][5] = new ChessPawn(this.board, 1, 5,false);\n        this.board[1][6] = new ChessPawn(this.board, 1, 6,false);\n        this.board[1][7] = new ChessPawn(this.board, 1, 7,false)\n\n\n\n\n        const whiteKing = new ChessKing(this.board, 7, 3,true);\n        this.board[7][3] = whiteKing\n        this.board[7][0] = new ChessRook(this.board, 7, 0,true);\n        this.board[7][7] = new ChessRook(this.board, 7, 7,true);\n        this.board[7][1] = new ChessKnight(this.board, 7, 1,true);\n        this.board[7][6] = new ChessKnight(this.board, 7, 6,true);\n        this.board[7][4] = new ChessQueen(this.board, 7, 4,true);\n        this.board[7][2] = new ChessBishop(this.board, 7, 2,true);\n        this.board[7][5] = new ChessBishop(this.board, 7, 5,true);\n\n        this.board[6][0] = new ChessPawn(this.board, 6, 0,true);\n        this.board[6][1] = new ChessPawn(this.board, 6, 1,true);\n        this.board[6][2] = new ChessPawn(this.board, 6, 2,true);\n        this.board[6][3] = new ChessPawn(this.board, 6, 3,true);\n        this.board[6][4] = new ChessPawn(this.board, 6, 4,true);\n        this.board[6][5] = new ChessPawn(this.board, 6, 5,true);\n        this.board[6][6] = new ChessPawn(this.board, 6, 6,true);\n        this.board[6][7] = new ChessPawn(this.board, 6, 7,true);\n\n\n\n       \n        \n        // set the aims for all pieces, whom they should protect and whom they should all attack\n        for (let i = 0; i < this.board.length; i++) {\n            for (let j = 0; j < this.board[i].length; j++) {\n                const cell = this.board[i][j];\n                if (cell) {\n                    if (cell.isPieceWhite) { // if its my piece\n\n                        cell.king = whiteKing;\n                        cell.oppKing = blackKing;\n                    } else {\n                        cell.oppKing = whiteKing;\n                        cell.king = blackKing;\n                    }\n\n                }\n\n            }\n        }\n    }\n\n    toString() {\n        return JSON.stringify(this.board.map(r => r.map(_ => _ ? `${_.name}` : 'null')));\n    }\n\n}\n\n\n\n\n","import { useEffect, useRef, useState } from \"react\";\nimport { ChessBoard } from \"./engine/ChessBoard\";\nimport './Chess.css';\nimport { ChessPiece } from \"./engine/ChessPiece\";\n\nconst boardWidth = Math.min(window.innerHeight, window.innerWidth) - 50\nconst pieceWidth = boardWidth / 8;\n\nfunction ChessGame() {\n\n    const [board, setBoard] = useState([] as ChessPiece[][] | null[][])\n    const [availableMoves, setAvailableMoves] = useState({} as { [id: string]: boolean })\n    const [selectedPiece, setSelectedPiece] = useState(null as ChessPiece | null)\n\n    const chessBoardRef = useRef(new ChessBoard());\n    const chessBoard = chessBoardRef.current;\n    const [isWhiteTurnToPlay, setIsWhiteTurnToPlay] = useState(true);\n\n\n    function reloadBoard() {\n        setBoard(chessBoard.board)\n\n        setAvailableMoves({});\n        setSelectedPiece(null);\n    }\n\n\n    useEffect(() => {\n\n        reloadBoard()\n\n\n    }, [])\n\n    function onPieceClick(piece: ChessPiece | null, y: number, x: number) {\n        if (availableMoves[y + \",\" + x]) {\n            if (!selectedPiece?.move(y, x)) {\n                // invalid move\n                return;\n            }\n\n            reloadBoard()\n\n            setIsWhiteTurnToPlay(!isWhiteTurnToPlay)\n\n\n        } else if (piece) {\n            if (isWhiteTurnToPlay !== piece.isPieceWhite) return;\n\n\n            // show available moves\n            const a = piece.availableMoves();\n\n            const _: { [id: string]: boolean } = {}\n            a.forEach(m => {\n\n                _[m.positionYIndex + \",\" + m.positionXIndex] = true\n            });\n\n            setAvailableMoves(_);\n            setSelectedPiece(piece);\n\n        } else {\n            setAvailableMoves({});\n            setSelectedPiece(null);\n        }\n\n    }\n\n    return (\n        <div className=\"Chess\">\n            <div className='Board' style={{ width: boardWidth + 'px', height: boardWidth + 'px' }} >\n                {board.map((row: ChessPiece[] | null[], y: number) => {\n\n                    return (<div key={y} className='Board-Y' style={{ display: 'flex' }}>\n\n\n\n                        {row.map((piece: ChessPiece | null, x: number) => {\n\n                            const shouldHighlight = availableMoves[y + \",\" + x];\n                            return (<div onClick={() => onPieceClick(piece, y, x)} key={x} className='Board-X' style={{ width: pieceWidth + 'px', height: pieceWidth + 'px', backgroundColor: (x % 2 === 0) === (y % 2 === 0) ? 'rgba(245, 222, 179, 0.596)' : '' }}>\n                                <div className={!piece ? '' : (isWhiteTurnToPlay !== piece.isPieceWhite) ? 'Piece-inner-invalid' : 'Piece-inner-valid'} style={{ width: '70%', height: '70%', display: 'flex', justifyContent: 'center', alignItems: 'center', backgroundColor: !(shouldHighlight || piece && piece === selectedPiece) ? '' : 'rgba(255, 255, 0, 0.5)' }}>\n                                    {piece ? <i className={piece.icon} style={{ color: (piece.isPieceWhite ? \"white\" : \"black\") }} ></i> : ''}\n\n                                </div>\n                            </div>\n\n\n                            )\n                        })}\n\n\n\n                    </div>\n\n\n                    )\n                })}\n            </div>\n            <div className='Side' style={{ padding: '20px' }} >\n                Piece To Play\n                <br />\n                <i className={'fa fa-chess '} style={{ color: isWhiteTurnToPlay ? 'white' : 'black' }} ></i>\n            </div>\n        </div>\n    );\n}\n\nexport default ChessGame;\n","import logo from './logo.svg';\nimport { BrowserRouter, Link, Redirect, Route, Router, Switch } from 'react-router-dom'\nimport ChessGame from './chess';\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <Switch>\n\n\n        <Route path=\"/chess\" component={ChessGame} />\n\n\n        <Redirect path=\"/\" to=\"chess\" />\n\n\n\n      </Switch>\n\n    </BrowserRouter>\n\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}